Sorting algorithm is very famous to Algorithm where we have to organised things in any order.
There are many Sorting Algorithm exist some of them are:
1. Selection Sort -  in every round the smallest value takes their correct place.
2. Bubble Sort - in every round the largest value takes their correct place.
3. Insertion Sort - take one index and shift to left while less
Selection Sort - 
    - insert the ith minimum value at ith position by swapping
    first take the 0 th index then check the minimum in rest if found then swap further go to n - 1 index
    - Time complexity is O(n2) same in best case and worst case

    Use Case - If size of arr is small
    
    Create FlowChart of this algorithm

Bubble Sort - 
    - compare with neighbour element if A[i+1] < A[i] then swap it. this will get the first largest element at there position.
        Perform this for n-1 times that will arrange all the largest value from last to first
    - eg:       [4, 9, 6, 3, 8, 5, 10, 7]
                [4, 6, 3, 8, 5, 9, 7, 10]
                [4, 3, 6, 5, 8, 7, 9, 10]
                [3, 4, 5, 6, 7, 8, 9, 10]
                [3, 4, 5, 6, 7, 8, 9, 10]
                [3, 4, 5, 6, 7, 8, 9, 10]
                [3, 4, 5, 6, 7, 8, 9, 10]
                [3, 4, 5, 6, 7, 8, 9, 10]
    Use Case - In ith iteration we put ith largest element to its position
    - Time complexity - O(n2) , Space complexity = O(1)
    - Best Case - O(n)   
    * In place sorting - Do not use extra space

Insertion Sort - 
    - Iterate all index and check for every index element while less than left SHIFT that
        eg -   [7,9,6,2,4]
               [7,9,6,2,4]
               [7,6,9,2,4]
               [6,7,9,2,4]
               [6,7,2,9,4]
               [6,2,7,9,4]
               [2,6,7,9,4]
               [2,6,7,4,9]
               [2,6,4,7,9]
               [2,4,6,7,9] # FOUND Sorted
      Use Case - Adaptable and stable
    - Time Complexity - O(n2) Space Complexity - O(1)
    - Best Case O(n) worst case complexity O(n2)



